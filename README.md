# Linux Systems Programming Laboratory

A hands-on exploration of Linux system internals and low-level programming concepts

### Core Learning Tracks

#### 1. Fundamentals of Memory and Process

- [ ] Memory layout exploration via custom program analysis
- [ ] Process memory mapping investigation
- [ ] Virtual memory page table walker implementation
- [ ] x86_64 assembly basics with GDB examination

#### 2. System Interface Layer

- [ ] Implement custom file operations library
- [ ] Build signal handling framework
- [ ] Create error handling wrapper library
- [ ] Design and implement basic system call
- [ ] File descriptor implementation study

#### 3. Process & Thread Management

- [ ] Process creation and management suite
- [ ] Thread pool implementation
- [ ] Context switch examination tool
- [ ] Basic process scheduler implementation
- [ ] Process state monitor

#### 4. Inter-Process Communication Suite

- [ ] Bidirectional pipe communication system
- [ ] Shared memory segment manager
- [ ] Message queue implementation
- [ ] Unix domain socket framework
- [ ] IPC performance comparison tool

#### 5. Concurrency Engineering

- [ ] Custom mutex implementation
- [ ] Semaphore from scratch
- [ ] Reader-writer lock system
- [ ] Deadlock detection tool
- [ ] Lock-free queue implementation

#### 6. Network Programming Fundamentals

- [ ] TCP/UDP client-server framework
- [ ] Custom protocol implementation
- [ ] Non-blocking I/O server
- [ ] Event-driven server using epoll
- [ ] Network protocol analyzer

#### 7. Advanced System Concepts

- [ ] Memory mapper utility
- [ ] Dynamic library loader
- [ ] ELF file parser
- [ ] Custom memory allocator
- [ ] Basic kernel module

### Learning Philosophy

- Each concept is learned through simple practical implementation
- Understanding the "why" behind system behaviors

### Purpose

- Understand the fundamental principles of software engineering at a low level
